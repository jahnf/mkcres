{"name":"mkcres","tagline":"A tool for generating and maintaining C/C++ resource files to be embedded in a program.","body":"mkcres\r\n======\r\n\r\nmkcres is a Python tool for generating and maintaining C/C++ resource \r\nfiles that can be embedded in a program. mkcres comes with a python comand \r\nline tool and also a header and source for easy access to the embedded \r\nresources within the program.\r\n\r\nBasically mkcres takes a JSON configuration file and turns it into a bunch \r\nof C source files that can be compiled together with your project and \r\nincluded in your build process. It also supports partial updates of the \r\ngenerated C files since mkcres only updates files if the modification \r\ndate of a file changes. A single file can appear in the resources multiple\r\ntimes under a different name but will be compiled in only once.\r\n\r\n**Table of Contents** \r\n\r\n- [Usage](#usage)\r\n  - [Configuration](#configuration)\r\n  - [Command line options](#command-line-options)\r\n  - [Usage in your C code](#usage-in-your-c-code)\r\n    - [Get a resource](#get-a-resource)\r\n    - [Loop throuh all resources](\"#loop-throuh-all-resources)\r\n  - [Integrate with CMake](#integrate-with-cmake)\r\n    - [Drawbacks with CMake](#drawbacks-with-cmake)\r\n  - [Integrate within a Makefile](#integrate-within-a-makefile)\r\n- [Dependencies](#dependencies)\r\n- [License](#license)\r\n\r\nUsage\r\n-----\r\nmkcres should work with Python versions 2 and 3, but will require at least \r\nversion 2.7 since the `argparse` is used.\r\n\r\n### Configuration\r\n\r\nThe configuration is done in a JSON file. The file has to contain the \r\n`CRES` value, which is an array of prefix conigurations. A prefix\r\nconfiguration can contain the `prefix` and an array of `files`.\r\nA resource can be later found and referenced via *prefix + filename* or\r\n*prefix + alias* if the alias for a resource file is set.\r\nIf *prefix* is not set, it will be automatically an empty string.\r\n\r\n\r\nHere is an example JSON configuration file:\r\n\r\n``` json\r\n{ \r\n  \"CRES\": [\r\n    {\r\n      \"prefix\": \"icons/\",\r\n      \"files\": [\r\n        { \"name\": \"img/app32x32.png\" },\r\n        { \"name\": \"x.png\", \"alias\": \"img/exit.png\" }\r\n      ]\r\n    }, \r\n    {\r\n      \"prefix\": \"other_stuff/\",\r\n      \"files\": [\r\n        { \"name\": \"encryption_key_v1.pub\", \"alias\": \"key.pub\" },\r\n        { \"name\": \"lookup.sqlite\" }\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n### Command line options\r\n\r\n- [ ] *TODO*: Describe command line usage and arguments\r\n\r\n### Usage in your C code\r\n\r\nTo use the resources compiled with your executable code include the \r\nmkcres C-header [cresource.h](cresource.h).\r\n```c\r\n#include \"cresource.h\"\r\n```\r\nAlso have a look at the [examples](examples) in the example directory.\r\n\r\n##### Get a resource\r\n\r\nUse the function `get_cresource` to get a resource file:\r\n```c\r\n/** Get a resource with the given filename. Returns a null ptr if the resource\r\n* was not found. */\r\ncresource_t* get_cresource(const char* filename);\r\n```\r\nIf the resource exists, the function will return a pointer to a `cresource_t`\r\nstruct, `null` otherwise. This is how `cresource_t` is defined:\r\n```c\r\ntypedef const struct {\r\nconst char *name;\r\nconst unsigned long size;\r\nconst unsigned char *data;\r\n} cresource_t;\r\n```\r\n\r\n##### Loop throuh all resources\r\n\r\n*TODO*\r\n\r\n### Integrate with CMake\r\n\r\nFor easy use within CMake files the function `mkcres_add_library(name config_file mkcres_dir)` \r\nof the helper script `mkcres.cmake` can be used.  Lets have a look at a simple example:\r\n\r\n```CMake\r\n# Assuming you have all the mkcres files in a subdirectory called 'mkcres'\r\n# (mkcres.cmake mkcres.py cresource.c cresource.h)\r\n\r\ninclude(mkcres/mkcres.cmake)\r\nmkcres_add_library(myresources resources.json \"./mkcres\")\r\n\r\nadd_executable(example main.c)\r\ntarget_link_libraries(example myresources)\r\n```\r\n\r\nUsing the `mkcres_add_library` function will automatically add additional \r\nmake targets to your project:\r\n* *mkcres-update*: will update the C resource files form all \r\n  targets added with `mkcres_add_library`\r\n* *mkcres-force-rewrite*: will rewrite all the C resource files \r\n  completely from all targets added with `mkcres_add_library`\r\n\r\nFor a full example have a look at the [CMake example](examples/example-cmake) \r\nin the examples directory.\r\n\r\n##### Drawbacks with CMake\r\n\r\n**run `make mkcres-update` before running `make`** when changing the \r\nJSON resource configuration so that resources files are added or \r\nremoved - otherwise the first `make` call will result in an error.\r\n*Here is why:*\r\n\r\nOnce a CMake build is configured and if the JSON configuration is changed, \r\nso that resources files are added or removed the first `make` call will \r\nresult in either a linker or a CMake error. This is because CMake needs \r\nthe full list of source files for a target (executable or library)\r\nat configuration time. In the background mkcres.py creates another \r\nCMake file that will be included from mkcres.cmake. This file contains the\r\nlist of C-resource files to be compiled.\r\n\r\nA `make` step will update the generated include file for CMake but this \r\nis at a point where CMake already has included the file to change and \r\nwill only be detected from CMake with the next `make` run. Unfortunately\r\nthere is no way around this.\r\n\r\n### Integrate within a Makefile\r\n\r\nmkcres can be integrated with basically everywhere where Python is available.\r\nFor an integration into your Makefiles have a look at the \r\n[Makefile example](examples/example-make) in the examples directory.\r\n\r\nDependencies\r\n------------\r\nmkcres needs Python version 2.7 or higher since it uses the argparse library.\r\n\r\nLicense\r\n-------\r\nSee [LICENSE](https://github.com/jahnf/mkcres/blob/master/LICENSE).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}